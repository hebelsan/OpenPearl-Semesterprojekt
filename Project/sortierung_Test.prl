
MODULE(test);
! i/o configuration of the HFU ball sorter machine

SYSTEM;
   ! test with ball sorter
!  ls1_8: PCF8574In('20'B4, 7,8) --- i2cbus;
!  ls9:   PCF8574In('21'B4, 0,1) --- i2cbus;
!  esAuf: PCF8574In('21'B4, 1,1) --- i2cbus;
!  esZu:  PCF8574In('21'B4, 2,1) --- i2cbus;
!  esNotaus:  PCF8574In('21'B4, 3,1) --- i2cbus;
!  fahr: PCF8574Out('21'B4,6,2) ---  i2cbus; ! (auf, zu)
!  hm1_7: PCF8574Out('22'B4,6,7) --- i2cbus;
!  i2cbus: I2CBus('/dev/i2c-1');
  termout: StdOut;

__cpp__(
'static pearlrt::I2CBus s_i2cbus((char*)"/dev/i2c-1");'

'pearlrt::ADS1015SE s_channel0(&s_i2cbus, 0x48,0,2);'
'pearlrt::Device*  d_channel0 = &s_channel0;'

'extern pearlrt::Device* d_channel0;'
'pearlrt::SystemDationB * _channel0 = (pearlrt::SystemDationB*) d_channel0;'

'static pearlrt::PCF8574Out s_hm_1_7(&s_i2cbus, 0x22, 6, 7);'
'pearlrt::Device * d_hm_1_7 = &s_hm_1_7;'
'pearlrt::SystemDationB * _hm1_7 = (pearlrt::SystemDationB*) d_hm_1_7;'

'static pearlrt::PCF8574In s_ls1_8(& s_i2cbus, 0x20, 7, 8);'
'pearlrt::Device * d_ls1_8 = &s_ls1_8;'
'pearlrt::SystemDationB * _ls1_8 = (pearlrt::SystemDationB*) d_ls1_8;'

'static pearlrt::PCF8574In s_ls9(& s_i2cbus, 0x21, 0, 1);'
'pearlrt::Device * d_ls9 = &s_ls9;'
'pearlrt::SystemDationB * _ls9 = (pearlrt::SystemDationB*) d_ls9;'

'static pearlrt::PCF8574In s_error(& s_i2cbus, 0x21, 4, 1);'
'pearlrt::Device * d_error = &s_error;'
'pearlrt::SystemDationB * _error = (pearlrt::SystemDationB*) d_error;'

'static pearlrt::PCF8574Out s_fahr(& s_i2cbus, 0x21, 6, 2);'
'pearlrt::Device * d_fahr = &s_fahr;'
'pearlrt::SystemDationB * _fahr = (pearlrt::SystemDationB*) d_fahr;'

'static pearlrt::PCF8574In s_esNotaus(& s_i2cbus, 0x21, 3, 1);'
'pearlrt::Device * d_esNotaus = &s_esNotaus;'
'pearlrt::SystemDationB * _esNotaus = (pearlrt::SystemDationB*) d_esNotaus;'

'static pearlrt::PCF8574In s_esAuf(& s_i2cbus, 0x21, 1, 1);'
'pearlrt::Device * d_esAuf = &s_esAuf;'
'pearlrt::SystemDationB * _esAuf = (pearlrt::SystemDationB*) d_esAuf;'

'static pearlrt::PCF8574In s_esZu(& s_i2cbus, 0x21, 2, 1);'
'pearlrt::Device * d_esZu = &s_esZu;'
'pearlrt::SystemDationB * _esZu = (pearlrt::SystemDationB*) d_esZu;'
);

PROBLEM;
 
 SPC termout DATION OUT SYSTEM ALPHIC GLOBAL;


DCL console DATION OUT ALPHIC DIM(*,80) FORWARD NOSTREAM CREATED(termout);
DCL uls1_8 DATION IN BASIC BIT(8) CREATED(ls1_8);
DCL uls9   DATION IN BASIC BIT(1) CREATED(ls9);
DCL uesa   DATION IN BASIC BIT(1) CREATED(esAuf);
DCL uesz   DATION IN BASIC BIT(1) CREATED(esZu);
DCL uerror   DATION IN BASIC BIT(1) CREATED(error);
DCL uesna  DATION IN BASIC BIT(1) CREATED(esNotaus);
DCL ufahr DATION OUT BASIC BIT(2) CREATED(fahr);
DCL uhm1_7 DATION OUT BASIC BIT(7) CREATED(hm1_7);

DCL ch0 DATION IN BASIC FIXED(15) CREATED(channel0);
DCL v0 FIXED(15);

DCL true BIT(1) INIT('1'B1);
DCL false BIT(1) INIT('0'B1);

!semaphoren
DCL commonData SEMA PRESET(1);
DCL beginn SEMA PRESET(1);
DCL waagefrei SEMA PRESET(1);

!lichtschranken
DCL ls BIT(9);
DCL (l1, l2, l3, l4, l5, l6, l7, l8, l9) BIT(1);

!motor
DCL (esa,esz,esna,err) BIT(1);
DCL driveJob BIT(2);

!klappen
DCL (current, allOff) BIT(7) INIT('0000001'B1, '0000000'B1);
DCL (k1,k2,k3,k4,k5,k6,k7) BIT(7) INIT('0000001'B1,'0000010'B1,'0000100'B1,'0001000'B1,'0010000'B1,'0100000'B1,'1000000'B1);



dumpInputs: TASK MAIN;
   
   OPEN console;

   ACTIVATE kicker;
   ACTIVATE motor;
   ACTIVATE readInputs;
   ACTIVATE stoser;

   PUT 'PCF8574 Test started' TO console BY A, SKIP;
   REPEAT
      PUT 'LS9-1: ', ls TO console BY A,B1(9),SKIP;
      PUT 'LS-2: ', l2, '  LS-3: ',l3, '    LS-9: ',l9 TO console BY  A,B1(1),A,B(1),A,B1(1);
      PUT ' DMP : auf: ', esa, ' zu: ', esz, ' notaus: ', esna TO console
         BY    A,        B1(1), A,    B1(1),   A, B1(1);
      PUT '  /Error: ' , err TO console BY A, B1(1);
      PUT '  Durchmesser: ', v0 TO console BY A, F(6);
      PUT '  Drive: ' , driveJob TO console BY A, B1(2), SKIP; 
      AFTER 0.5 SEC RESUME;
   END;
END;


motor: TASK PRIO 3;
   DCL (auf,zu,stop) BIT(2) INIT('01'B1, '10'B1, '00'B1);
   DCL lastJob BIT(2) INIT('11'B1);
   DCL count FIXED INIT(0);
   OPEN ufahr;
   
   /*
   WHILE count < 10 REPEAT
      REQUEST commonData;

      IF esa EQ true THEN
         driveJob := zu; ! close
      FIN;
      IF esz EQ true THEN 
	 driveJob := auf; ! open
      FIN;
      IF esna EQ true THEN
         driveJob := auf; ! open
      FIN;
      RELEASE commonData;
      ! only this task writes the variable driveJob
      ! thats why it is save to used it without sema
      IF lastJob NE driveJob THEN
         SEND driveJob TO ufahr;
         lastJob := driveJob;
         count := count + 1;
      FIN;
      AFTER 0.01 SEC RESUME;
   END;
   driveJob := stop;
   SEND stop TO ufahr;
   */


   REPEAT
    IF l2 EQ true THEN
	IF esa EQ true THEN
	   AFTER 1 SEC RESUME;
	   REQUEST commonData;	
	   SEND zu TO ufahr;
	   RELEASE commonData;
	FIN;
    FIN;
    IF esz EQ true THEN
	  REQUEST commonData;
	  SEND stop TO ufahr;
	  AFTER 2 SEC RESUME;
          SEND auf TO ufahr;
          RELEASE commonData; !muss neu abfragen können ob zu ist oder aus
	 
	  WHILE esa NE true REPEAT
	  ! PUT 'warte' TO console BY A,SKIP;
	  END;
	  REQUEST commonData;
	  SEND stop TO ufahr;
	  RELEASE commonData;

         
	  REQUEST waagefrei;  !klappe geht nur auf, wenn waagefrei
	  SEND k2 TO uhm1_7;
          PUT 'k2 geoeffnet' TO console BY A, SKIP;
          AFTER 1 SEC RESUME;
          SEND allOff  TO uhm1_7;
          PUT 'k2 geschlossen' TO console BY A, SKIP;
	  RELEASE beginn; 
    FIN;
   END;
  
END;


readInputs: TASK PRIO 5;
  
   !lichtschranken
   DCL b8 BIT(8);
   DCL b1 BIT(1);
   OPEN uls1_8;
   OPEN uls9;

   !motor
   OPEN uesa;
   OPEN uesz;
   OPEN uesna;
   OPEN uerror;

   OPEN ch0;

   REPEAT
      REQUEST commonData;

      TAKE b8 FROM uls1_8;
      TAKE b1 FROM uls9;
      __cpp__('_ls = _b1.bitCat(_b8);');

      !lichtschranke 1 und neun einzeln auslesen
      __cpp__(' _l9 = _ls.getBit(1);');
      __cpp__(' _l1 = _ls.getBit(9);');
      __cpp__(' _l2 = _ls.getBit(8);');
      __cpp__(' _l3 = _ls.getBit(7);');

      TAKE esa FROM uesa;
      TAKE esz FROM uesz;
      TAKE esna FROM uesna;
      TAKE err FROM uerror;

      TAKE v0 FROM ch0;

      RELEASE commonData;
      AFTER 0.1 SEC RESUME;
   END;
END;



kicker: TASK PRIO 2;
  

   OPEN uhm1_7;

    REPEAT
      IF l1 EQ true THEN
       REQUEST beginn;
       SEND k1 TO uhm1_7;
       PUT 'k1 geoeffnet' TO console BY A, SKIP;
       AFTER 1 SEC RESUME;
       SEND allOff  TO uhm1_7;
       PUT 'k1 geschlossen' TO console BY A, SKIP;
       !wenn nächste lichtschranke sieht und klappe 2 auf geht kann nächste kugel
      FIN;        
	
    END;
END;


stoser: TASK PRIO 4;

	REPEAT
	
         IF l3 EQ true THEN
          AFTER 4 SEC RESUME;
          SEND k3 TO uhm1_7;
          PUT 'k3 geoeffnet' TO console BY A, SKIP;
          AFTER 1 SEC RESUME;
          SEND allOff  TO uhm1_7;
          PUT 'k3 geschlossen' TO console BY A, SKIP;
          RELEASE waagefrei;
         FIN;

        END;


END;

MODEND;
